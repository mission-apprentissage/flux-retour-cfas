import fs from "fs";
import path from "path";
import { upperFirst } from "lodash-es";

// eslint-disable-next-line node/no-unpublished-import
import prettier from "prettier";
// eslint-disable-next-line node/no-unpublished-import
import { compileBSON, getDatabaseSchemas } from "bson-schema-to-typescript";
// eslint-disable-next-line node/no-unpublished-import
import traverse from "json-schema-traverse";

import config from "../../../config.js";

export async function prettierOptions(path: string): Promise<prettier.Options> {
  const options = await prettier.resolveConfig(path);

  return {
    ...options,
    parser: "typescript",
  };
}

const OUTPUT_DIR = "src/common/model/@types";
const IGNORE_COLLECTIONS = [
  "archiveDossiersApprenants",
  "cfas",
  "changelog",
  "dossiersApprenants",
  "duplicatesEvents",
  "effectifsApprenants",
  "referentielSiret",
];

/**
 * Ce job génère les types typescript à partir des schemas mongodb.
 * Les schemas sont appliqués sur les collections de la base de données dans runScript,
 * et nous lancons la CLI avec --transpileOnly pour éviter que des erreurs de typage soit remontées
 * avant que les types ne soient générés.
 */
export const generateTypes = async () => {
  // Get schemas for all collections from the MongoDB server
  const schemas = (await getDatabaseSchemas(config.mongodb.uri, ""))
    .filter(({ collectionName }) => !IGNORE_COLLECTIONS.includes(collectionName))
    .sort((a, b) => (a.collectionName > b.collectionName ? 1 : -1));

  console.info("Generating typescript types for MongoDB collection schemas");

  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  for (const { schema, collectionName } of schemas) {
    let manuallyUpdated = false;
    let newFile = false;
    let destination;
    let title;

    if (schema?.title) {
      title = (schema.title as string)?.replace(/s$/, "");

      destination = `${path.join(OUTPUT_DIR, upperFirst(title))}.ts`;

      // only overwrite the file if it does not exist, or if it is still auto-generated
      newFile = !fs.existsSync(destination);
      manuallyUpdated = fs.existsSync(destination) && !fs.readFileSync(destination, "utf8").includes("auto-generated");
    }

    const logs = [collectionName.padEnd(30), " > "];
    if (manuallyUpdated) {
      logs.push("Manually updated, skipping");
    } else if (!schema) {
      logs.push("No schema, skipping");
    } else if (!title) {
      logs.push("No schema title, skipping");
    } else {
      // trick to replace any bson type by any TS
      traverse(schema, (node) => {
        if (Array.isArray(node?.bsonType) && node?.bsonType?.length > 5) {
          node.bsonType = "any";
        }
      });

      const output = await compileBSON(
        { ...schema, title },
        {
          bannerComment: ["// auto-generated by bson-schema-to-typescript"],
          enableConstEnums: true,
          ignoreMinAndMaxItems: false,
          strictIndexSignatures: false,
          unknownAny: true,
          prettier: await prettierOptions(destination),
        }
      );
      const finalOutput = output
        // replace what is supposed to be an ObjectID by any
        .replace(/{\s+\[k: string\]: unknown;\s+}/gi, "any")
        // remove additionalProperties
        .replace(/\s+\[k: string\]: unknown;/gi, "");

      logs.push(newFile ? "Create" : "Update");
      logs.push(destination);
      fs.writeFileSync(destination, finalOutput);
    }
    console.info(...logs);
  }
};
