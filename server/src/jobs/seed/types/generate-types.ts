import fs from "fs";
import path from "path";

// TODO à déplacer en dehors de la codebase car dépendances de dev
import { compileBSON, getDatabaseSchemas } from "bson-schema-to-typescript";
import traverse from "json-schema-traverse";
import { upperFirst } from "lodash-es";
import prettier from "prettier";

import config from "@/config";

export async function prettierOptions(path: string): Promise<prettier.Options> {
  const options = await prettier.resolveConfig(path);

  return {
    ...options,
    parser: "typescript",
  };
}

const OUTPUT_DIR = "../shared/models/data/@types";
const IGNORE_COLLECTIONS = [
  "archiveDossiersApprenants",
  "cfas",
  "changelog",
  "dossiersApprenants",
  "duplicatesEvents",
  "effectifsApprenants",
  "referentielSiret",
];

/**
 * Ce job génère les types typescript à partir des schemas mongodb.
 * Les schemas sont appliqués sur les collections de la base de données dans runScript,
 * et nous lancons la CLI avec --transpileOnly pour éviter que des erreurs de typage soit remontées
 * avant que les types ne soient générés.
 */
export const generateTypes = async () => {
  // Get schemas for all collections from the MongoDB server
  const schemas = (await getDatabaseSchemas(config.mongodb.uri, ""))
    .filter(({ collectionName }) => !IGNORE_COLLECTIONS.includes(collectionName))
    .sort((a, b) => (a.collectionName > b.collectionName ? 1 : -1));

  console.info("Generating typescript types for MongoDB collection schemas");

  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  for (const { schema, collectionName } of schemas) {
    let manuallyUpdated = false;
    let newFile = false;
    let destination;
    let title;

    if (schema?.title) {
      title = (schema.title as string)?.replace(/s$/, "");

      destination = `${path.join(OUTPUT_DIR, upperFirst(title))}.ts`;

      // only overwrite the file if it does not exist, or if it is still auto-generated
      newFile = !fs.existsSync(destination);
      manuallyUpdated = fs.existsSync(destination) && !fs.readFileSync(destination, "utf8").includes("auto-generated");
    }

    const logs = [collectionName.padEnd(30), " > "];
    if (manuallyUpdated) {
      logs.push("Manually updated, skipping");
    } else if (!schema) {
      logs.push("No schema, skipping");
    } else if (!title) {
      logs.push("No schema title, skipping");
    } else {
      // trick to replace any bson type by any TS
      traverse(schema, (node) => {
        if (Array.isArray(node?.bsonType) && node?.bsonType?.length > 5) {
          node.bsonType = "any";
        }
      });

      const output = await compileBSON(
        { ...schema, title },
        {
          bannerComment: [
            "// auto-generated by bson-schema-to-typescript",
            ...[countObjectId(schema) > 1 ? 'import { ObjectId } from "mongodb";' : ""],
          ],
          enableConstEnums: true,
          ignoreMinAndMaxItems: false,
          strictIndexSignatures: false,
          unknownAny: true,
          prettier: await prettierOptions(destination),
        }
      );
      const finalOutput = output
        // replace unknown fields by any (including ObjectId)
        .replace(/{\s+\[k: string\]: unknown;\s+}/gi, "any")
        // remove all _id
        .replace(/\s+_id\??: any;/g, "")
        // fix ObjectIds
        .replace(/(\w*_id\??): any;/g, "$1: ObjectId;")
        // fix ObjectIds Or null in nested fields
        .replace(/(\w*_id\??): null;/g, "$1: ObjectId | null;")
        // remove additionalProperties
        .replace(/\s+\[k: string\]: unknown;/gi, "");

      logs.push(newFile ? "Create" : "Update");
      logs.push(destination);
      fs.writeFileSync(destination, finalOutput);
    }
    console.info(...logs);
  }
};

/**
 * Recursively checks if a schema relies on the ObjectId BSON type anywhere
 * Adapted from https://github.com/lirbank/bson-schema-to-typescript/blob/17a8537eec9e83f393b67d07527cc3b9cd4334df/src/compile.ts#L114-L133
 */
function countObjectId(schema: any): number {
  if (schema === null || typeof schema !== "object") {
    return 0;
  }

  if (Array.isArray(schema)) {
    return schema.reduce((acc, schema) => acc + countObjectId(schema), 0);
  }

  return Object.entries(schema).reduce((acc, [key, value]) => {
    if (key === "bsonType") {
      if (value === "objectId") return acc + 1;
      if (Array.isArray(value)) return acc + value.reduce((acc, v) => acc + (v === "objectId" ? 1 : 0), 0);
    }

    if (typeof value === "object") return acc + countObjectId(value);

    return acc;
  }, 0);
}
