import fs from "fs";
import path from "path";
import { upperFirst } from "lodash-es";

// eslint-disable-next-line node/no-unpublished-import
import prettier from "prettier";
// eslint-disable-next-line node/no-unpublished-import
import { compileBSON, getDatabaseSchemas } from "bson-schema-to-typescript";

import config from "../../../config.js";

export async function prettierOptions(path: string): Promise<prettier.Options> {
  const options = await prettier.resolveConfig(path);

  return {
    ...options,
    parser: "typescript",
  };
}

const OUTPUT_DIR = "src/common/model/@types";
const IGNORE_COLLECTIONS = [
  "archiveDossiersApprenants",
  "cfas",
  "changelog",
  "dossiersApprenants",
  "dossiersApprenantsApiErrors",
  "duplicatesEvents",
  "effectifsApprenants",
  "referentielSiret",
];

/**
 * Ce job génère les types typescript à partir des schemas mongodb.
 * Les schemas sont appliqués sur les collections de la base de données dans runScript,
 * et nous lancons la CLI avec --transpileOnly pour éviter que des erreurs de typage soit remontées
 * avant que les types ne soient générés.
 */
export const generateTypes = async () => {
  // Get schemas for all collections from the MongoDB server
  const schemas = await getDatabaseSchemas(config.mongodb.uri, "");

  console.info("Generating typescript types for MongoDB collection schemas");

  await Promise.all(
    schemas
      .filter(({ collectionName }) => !IGNORE_COLLECTIONS.includes(collectionName))
      .map(async ({ schema, collectionName }) => {
        // Do nothing when a collection has no schema
        if (!schema) return;

        const filename = typeof schema.title === "string" ? schema.title : null;
        if (!filename) throw new Error("A schema title is required");

        if (!fs.existsSync(OUTPUT_DIR)) {
          fs.mkdirSync(OUTPUT_DIR, { recursive: true });
        }

        const destination = `${path.join(OUTPUT_DIR, upperFirst(filename))}.ts`;

        const output = await compileBSON(schema, {
          bannerComment: ["/* eslint-disable */", "// auto-generated by bson-schema-to-typescript"],
          enableConstEnums: true,
          ignoreMinAndMaxItems: false,
          strictIndexSignatures: false,
          unknownAny: true,
          prettier: await prettierOptions(destination),
        });
        const finalOutput = output
          // replace what is supposed to be an ObjectID by any
          .replace(/{\s+\[k: string\]: unknown;\s+}/gi, "any")
          // remove additionalProperties
          .replace(/\[k: string\]: unknown;/gi, "");

        // only overwrite the file if it does not exist, or if it is still auto-generated
        const newFile = !fs.existsSync(destination);
        const manuallyUpdated =
          fs.existsSync(destination) && !fs.readFileSync(destination, "utf8").includes("auto-generated");

        const logs = [collectionName.padEnd(30), " > "];
        if (manuallyUpdated) {
          logs.push("Manually updated, skipping");
        } else if (!schema) {
          logs.push("No schema, skipping");
        } else {
          logs.push(newFile ? "Create" : "Update");
          logs.push(destination);
          fs.writeFileSync(destination, finalOutput);
        }
        console.log(...logs);
      })
  );
};
